<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>糸掛け曼荼羅ラボ</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#111418; --ink:#e6edf3; --muted:#97a1ab;
      --accent:#6ee7ff; --accent2:#a78bfa; --accent3:#f472b6;
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0; color:var(--ink); background:radial-gradient(1200px 700px at 70% -10%,#15202b00 30%,#10151b 70%), var(--bg);
      font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      display:grid; grid-template-columns: 1fr 360px; gap:16px; padding:16px;
    }
    header{grid-column:1/-1; display:flex; align-items:center; gap:12px; padding:6px 8px 0}
    header h1{font-size:18px; margin:0; letter-spacing:.02em}
    header .sub{color:var(--muted); font-size:12px}

    /* Canvas area */
    .stage-wrap{position:relative; min-height:420px; border-radius:16px; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,.45)}
    canvas{display:block; width:100%; height:100%; background:conic-gradient(from 210deg at 70% 20%, #0c0f14, #0e1117 60%, #0b0d10 100%);}    
    .hud{position:absolute; inset:8px auto auto 8px; display:flex; gap:8px; pointer-events:none}
    .chip{pointer-events:auto; background:rgba(16,19,24,.7); border:1px solid #1f2630; color:var(--ink); padding:6px 10px; border-radius:999px; font-size:12px; backdrop-filter:saturate(150%) blur(6px)}

    /* Control panel */
    aside{background:linear-gradient(180deg,#12161c,#0f1318 50%,#0e1116); border:1px solid #1f2630; border-radius:18px; padding:14px; position:sticky; top:16px; height:calc(100vh - 32px); overflow:auto}
    aside h2{font-size:14px; margin:12px 0 8px; letter-spacing:.06em; color:#c9d1d9}
    .row{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:8px 0}
    .row > label{color:var(--muted); font-size:12px}
    .row input[type="range"]{width:100%}
    .row .val{min-width:56px; text-align:right; color:#d2d9e0}
    .cols{display:grid; grid-template-columns:1fr 1fr; gap:8px}

    .group{border:1px solid #222a35; border-radius:14px; padding:10px; margin:10px 0; background:#0b0f14}
    .desc{color:#8c99a6; font-size:12px; margin:6px 0 2px}

    .btn{appearance:none; border:1px solid #2a3342; background:#121722; color:#dbe5f0; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600}
    .btn:hover{border-color:#3b4759}
    .btn.primary{background:linear-gradient(180deg,#263449,#1f2b3b); border-color:#3b4a62}
    .flex{display:flex; gap:8px; align-items:center}
    .row .toggle{display:flex; align-items:center; gap:6px}
    .row .toggle input{transform:translateY(1px)}

    footer{grid-column:1/-1; text-align:center; color:#718096; font-size:12px; padding-top:8px}
    a{color:#91caff; text-decoration:none}
    .help{margin-left:4px;color:#6ee7ff;font-weight:bold;cursor:help}
  </style>
</head>
<body>
  <header>
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none"><path d="M12 3v18M3 12h18" stroke="url(#g)" stroke-width="2" stroke-linecap="round"/><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#6ee7ff"/><stop offset="1" stop-color="#a78bfa"/></linearGradient></defs></svg>
    <h1>糸掛け曼荼羅ラボ</h1>
    <div class="sub">X/Y でピン間隔を個別調整・単一ピンの扇出し対応</div>
  </header>

  <main class="stage-wrap" id="stageWrap">
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="chip">クリックでピン選択（ソロモード時）</div>
    </div>
  </main>

  <aside>
    <div class="group">
      <h2>モード</h2>
      <p class="desc">操作を簡略化するモードです。</p>
      <div class="row"><label class="toggle"><input type="checkbox" id="easy"> 簡単モード <a class="help" href="docs/easy.html" target="_blank">?</a></label><div class="val"></div></div>

    </div>
    <div class="group">
      <h2>ボードとピン</h2>
      <div class="row"><label>キャンバス幅 <a class="help" href="docs/resolution.html" target="_blank">?</a></label><div class="val"><span id="resXVal">1024</span>px</div></div>
      <input type="range" id="resX" min="512" max="2048" step="64" value="1024"/>
      <div class="row"><label>キャンバス高さ <a class="help" href="docs/resolution.html" target="_blank">?</a></label><div class="val"><span id="resYVal">1024</span>px</div></div>
      <input type="range" id="resY" min="512" max="2048" step="64" value="1024"/>

      <div class="cols">
        <div>
          <div class="row"><label>上/下のピン数 (X) <a class="help" href="docs/pins.html" target="_blank">?</a></label><div class="val"><span id="nxVal">120</span></div></div>
          <input type="range" id="pinsX" min="4" max="400" step="1" value="120"/>
        </div>
        <div>
          <div class="row"><label>左/右のピン数 (Y) <a class="help" href="docs/pins.html" target="_blank">?</a></label><div class="val"><span id="nyVal">120</span></div></div>
          <input type="range" id="pinsY" min="4" max="400" step="1" value="120"/>
        </div>
      </div>

      <div class="cols">
        <div>
          <div class="row"><label>内側マージン <a class="help" href="docs/pins.html" target="_blank">?</a></label><div class="val"><span id="marginVal">28</span>px</div></div>
          <input type="range" id="margin" min="0" max="120" step="2" value="28"/>
        </div>
        <div>
          <div class="row"><label>ピン半径 <a class="help" href="docs/pins.html" target="_blank">?</a></label><div class="val"><span id="pinRVal">0</span>px</div></div>
          <input type="range" id="pinR" min="0" max="4" step="1" value="0"/>
        </div>
      </div>

      <div class="row"><label class="toggle"><input type="checkbox" id="showPins"> ピンを表示 <a class="help" href="docs/pins.html" target="_blank">?</a></label><div class="val"></div></div>
    </div>

    <div class="group advanced">
      <h2>パターン（周回インデックス）</h2>
      <p class="desc">ピンを長方形の外周に並べ、<em>i</em>番ピンから <em>(i × 乗数 + オフセット)</em> 番へ線を結びます。扇出しは「本数」と「ステップ」で制御。</p>
      <div class="row"><label>乗数 (multiplier) <a class="help" href="docs/multiplier.html" target="_blank">?</a></label><div class="val"><span id="mulVal">2.000</span></div></div>
      <input type="range" id="mul" min="0" max="20" step="0.001" value="2"/>

      <div class="row"><label class="toggle"><input type="checkbox" id="animate"> 乗数をアニメーション <a class="help" href="docs/animation.html" target="_blank">?</a></label><div class="val"></div></div>
      <div class="row"><label>速度 <a class="help" href="docs/animation.html" target="_blank">?</a></label><div class="val"><span id="speedVal">0.06</span></div></div>
      <input type="range" id="speed" min="0.005" max="0.2" step="0.005" value="0.06"/>


      <div class="cols">
        <div>
          <div class="row"><label>オフセット <a class="help" href="docs/offset.html" target="_blank">?</a></label><div class="val"><span id="offVal">0</span></div></div>
          <input type="range" id="offset" min="0" max="800" step="1" value="0"/>
        </div>
        <div>
          <div class="row"><label>線の本数/ピン <a class="help" href="docs/fan.html" target="_blank">?</a></label><div class="val"><span id="fanVal">1</span></div></div>
          <input type="range" id="fan" min="1" max="32" step="1" value="1"/>
        </div>
      </div>

      <div class="row"><label>ステップ（扇の開き） <a class="help" href="docs/fan.html" target="_blank">?</a></label><div class="val"><span id="stepVal">1</span></div></div>
      <input type="range" id="fanStep" min="1" max="400" step="1" value="1"/>

      <div class="cols">
        <div class="row"><label class="toggle"><input type="checkbox" id="solo"> ソロモード <a class="help" href="docs/solo.html" target="_blank">?</a></label><div class="val"></div></div>
        <div class="row"><label class="toggle"><input type="checkbox" id="skipSame"> 同一辺への接続を避ける <a class="help" href="docs/solo.html" target="_blank">?</a></label><div class="val"></div></div>
      </div>
      <div class="row"><label>選択ピン（ソロ） <a class="help" href="docs/solo.html" target="_blank">?</a></label><div class="val"><span id="selVal">0</span></div></div>
      <input type="range" id="selected" min="0" max="100" step="1" value="0"/>

      <div class="cols">
        <button class="btn" id="random">ランダム</button>
        <button class="btn" id="clearSel">選択解除</button>
      </div>
    </div>

    <div class="group advanced">
      <h2>色と描画</h2>
      <div class="row"><label>色モード <a class="help" href="docs/color.html" target="_blank">?</a></label>
        <select id="colorMode" class="btn">
          <option value="solid">単色</option>
          <option value="start">開始ピン基準グラデ</option>
          <option value="dest">到達ピン基準グラデ</option>
          <option value="fan">扇の本数でグラデ</option>
        </select>
      </div>
      <div class="cols">
        <div>
          <div class="row"><label>色相ベース <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="hueVal">200</span>°</div></div>
          <input type="range" id="hue" min="0" max="360" step="1" value="200"/>
        </div>
        <div>
          <div class="row"><label>色相スパン <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="spanVal">180</span>°</div></div>
          <input type="range" id="span" min="0" max="360" step="1" value="180"/>
        </div>
      </div>
      <div class="cols">
        <div>
          <div class="row"><label>彩度 <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="satVal">85</span>%</div></div>
          <input type="range" id="sat" min="0" max="100" step="1" value="85"/>
        </div>
        <div>
          <div class="row"><label>明度 <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="litVal">65</span>%</div></div>
          <input type="range" id="lit" min="0" max="100" step="1" value="65"/>
        </div>
      </div>
      <div class="cols">
        <div>
          <div class="row"><label>不透明度 <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="alphaVal">0.65</span></div></div>
          <input type="range" id="alpha" min="0.05" max="1" step="0.05" value="0.65"/>
          <div class="row"><label>線の太さ <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"><span id="lwVal">0.65</span>px</div></div>
          <input type="range" id="lw" min="0.2" max="2.0" step="0.05" value="0.65"/>
        </div>
        <div class="row"><label class="toggle"><input type="checkbox" id="glow" checked> 軽いグロー <a class="help" href="docs/color.html" target="_blank">?</a></label><div class="val"></div></div>
      </div>
      <div class="row"><label class="toggle"><input type="checkbox" id="animate"> 乗数をアニメーション <a class="help" href="docs/animation.html" target="_blank">?</a></label><div class="val"></div></div>
      <div class="row"><label>速度 <a class="help" href="docs/animation.html" target="_blank">?</a></label><div class="val"><span id="speedVal">0.06</span></div></div>
      <input type="range" id="speed" min="0.005" max="0.2" step="0.005" value="0.06"/>

    </div>

    <div class="group">
      <h2>描画操作</h2>
      <div class="cols">
        <button class="btn primary" id="redraw">再描画</button>
        <button class="btn" id="save">PNG保存</button>
      </div>
    </div>

    <div class="group">
      <h2>Tips</h2>
      <ul style="margin:6px 0 0 16px; color:#8fa3b8; padding:0">
        <li>ピン数 X/Y を別々に変えられるので、長辺/短辺でリズムを作れます。</li>
        <li>ソロモードでピンをクリック→「線の本数」「ステップ」を上げて扇出し。</li>
        <li>「同一辺への接続を避ける」で格子っぽさを弱め、対角の交差を強調。</li>
        <li>PNG 保存は高解像度（解像度スライダー）にしてからがおすすめ。</li>
      </ul>
    </div>
  </aside>

  <footer>© 2025 String‑Art Lab · square perimeter mapping</footer>

<script>
(() => {
  const dom = id => document.getElementById(id);
  const C = dom('c');
  const W = dom('stageWrap');
  const ctx = C.getContext('2d');

  const ui = {

    easyToggle: dom('easyToggle'),

    resX: dom('resX'), resXVal: dom('resXVal'),
    resY: dom('resY'), resYVal: dom('resYVal'),
    pinsX: dom('pinsX'), nxVal: dom('nxVal'),
    pinsY: dom('pinsY'), nyVal: dom('nyVal'),
    margin: dom('margin'), marginVal: dom('marginVal'),
    pinR: dom('pinR'), pinRVal: dom('pinRVal'),
    showPins: dom('showPins'),

    mul: dom('mul'), mulVal: dom('mulVal'),
    offset: dom('offset'), offVal: dom('offVal'),
    fan: dom('fan'), fanVal: dom('fanVal'),
    fanStep: dom('fanStep'), stepVal: dom('stepVal'),
    lw: dom('lw'), lwVal: dom('lwVal'),
    solo: dom('solo'), selected: dom('selected'), selVal: dom('selVal'),
    skipSame: dom('skipSame'),

    colorMode: dom('colorMode'),
    hue: dom('hue'), hueVal: dom('hueVal'),
    span: dom('span'), spanVal: dom('spanVal'),
    sat: dom('sat'), satVal: dom('satVal'),
    lit: dom('lit'), litVal: dom('litVal'),
    alpha: dom('alpha'), alphaVal: dom('alphaVal'),
    glow: dom('glow'),

    redraw: dom('redraw'), save: dom('save'),
    random: dom('random'), clearSel: dom('clearSel'),
  };

  const state = {
    pins: [], // {x,y,side}
    total: 0,
    selectedIndex: 0,

    animId: null,
    t: 0,
    easy: true,
  };

  const saved = {};
  const easyDefaults = {
    mul: 2,
    offset: 0,
    fan: 1,
    fanStep: 1,
    colorMode: 'solid',
    hue: 200,
    span: 180,
    sat: 85,
    lit: 65,
    alpha: 0.65,
    lw: 0.65,
    glow: true,
    animate: false,
    speed: 0.06,
    solo: false,
    selected: 0,
    skipSame: false,

  };

  // Utility: map value
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
function lerp(a,b,t){return a+(b-a)*t}

  function applyMode(){

    const simple = ui.easy.checked;
    document.querySelectorAll('.advanced').forEach(el => {
      el.style.display = simple ? 'none' : '';
    });
    if(simple){
      for(const k in easyDefaults){
        const el = ui[k];
        if(!el) continue;
        saved[k] = el.type === 'checkbox' ? el.checked : el.value;
        if(el.type === 'checkbox') el.checked = easyDefaults[k];
        else el.value = easyDefaults[k];
      }
    } else {
      for(const k in saved){
        const el = ui[k];
        if(!el) continue;
        if(el.type === 'checkbox') el.checked = saved[k];
        else el.value = saved[k];
      }
    }

    if(simple){
      ui.resX.min = ui.resY.min = 100;
      ui.resX.max = ui.resY.max = 2000;
      ui.resX.step = ui.resY.step = 100;
      ui.pinsX.max = ui.pinsY.max = 60;
    } else {
      ui.resX.min = ui.resY.min = 512;
      ui.resX.max = ui.resY.max = 2048;
      ui.resX.step = ui.resY.step = 64;
      ui.pinsX.max = ui.pinsY.max = 400;
    }
    const stepX = +ui.resX.step;
    const stepY = +ui.resY.step;
    ui.resX.value = clamp(Math.round(+ui.resX.value / stepX) * stepX, +ui.resX.min, +ui.resX.max);
    ui.resY.value = clamp(Math.round(+ui.resY.value / stepY) * stepY, +ui.resY.min, +ui.resY.max);
    ui.pinsX.value = clamp(+ui.pinsX.value, 4, +ui.pinsX.max);
    ui.pinsY.value = clamp(+ui.pinsY.value, 4, +ui.pinsY.max);
    ui.resXVal.textContent = ui.resX.value;
    ui.resYVal.textContent = ui.resY.value;
    ui.nxVal.textContent = ui.pinsX.value;
    ui.nyVal.textContent = ui.pinsY.value;
    ui.animate.dispatchEvent(new Event('change'));
  }

  function sizeCanvas(){
    const box = W.getBoundingClientRect();
    const resX = +ui.resX.value;
    const resY = +ui.resY.value;
    C.width = resX; C.height = resY;
    const width = box.width;
    const height = box.width * resY / resX;
    C.style.width = width + 'px';
    C.style.height = height + 'px';
    ui.resXVal.textContent = resX;
    ui.resYVal.textContent = resY;
  }

  function computePins(){
    const nX = +ui.pinsX.value; ui.nxVal.textContent = nX;
    const nY = +ui.pinsY.value; ui.nyVal.textContent = nY;
    const resX = +ui.resX.value; ui.resXVal.textContent = resX;
    const resY = +ui.resY.value; ui.resYVal.textContent = resY;
    const m = +ui.margin.value; ui.marginVal.textContent = m;

    const L = m, R = resX - m, T = m, B = resY - m;

    const pins = [];
    // Top edge: left->right, include corners
    for(let i=0;i<nX;i++){
      const t = i/(nX-1);
      pins.push({x: lerp(L,R,t), y: T, side: 'top'});
    }
    // Right edge: top->bottom (skip top corner)
    for(let i=1;i<nY;i++){
      const t = i/(nY-1);
      pins.push({x: R, y: lerp(T,B,t), side: 'right'});
    }
    // Bottom edge: right->left (skip bottom-right corner)
    for(let i=1;i<nX;i++){
      const t = i/(nX-1);
      pins.push({x: lerp(R,L,t), y: B, side: 'bottom'});
    }
    // Left edge: bottom->top (skip top-left & bottom-left already counted)
    for(let i=1;i<nY-1;i++){
      const t = i/(nY-1);
      pins.push({x: L, y: lerp(B,T,t), side: 'left'});
    }

    state.pins = pins;
    state.total = pins.length;

    // Clamp selected slider to range
    ui.selected.max = Math.max(0, state.total-1);
    state.selectedIndex = clamp(+ui.selected.value, 0, state.total-1);
    ui.selVal.textContent = state.selectedIndex;
  }

  function sideIndex(idx){
    // return side string quickly without reading object to help skipSame
    return state.pins[idx]?.side || '';
  }

  function colorFor(i, j, dest){
    const mode = ui.colorMode.value;
    const base = +ui.hue.value; ui.hueVal.textContent = base;
    const span = +ui.span.value; ui.spanVal.textContent = span;
    const sat = +ui.sat.value; ui.satVal.textContent = sat;
    const lit = +ui.lit.value; ui.litVal.textContent = lit;

    let t = 0;
    if(mode === 'solid') t = 0;
    else if(mode === 'start') t = i / Math.max(1, state.total-1);
    else if(mode === 'dest') t = dest / Math.max(1, state.total-1);
    else if(mode === 'fan') t = j / Math.max(1, (+ui.fan.value-1));
    const hue = (base + t * span) % 360;
    return `hsl(${hue} ${sat}% ${lit}%)`;
  }

  function draw(){
    const resX = +ui.resX.value;
    const resY = +ui.resY.value;
    const pins = state.pins;
    const total = state.total;
    const pinR = +ui.pinR.value; ui.pinRVal.textContent = pinR;

    // background
    ctx.clearRect(0,0,resX,resY);
    // Very soft vignette
    const minR = Math.min(resX, resY);
    const maxR = Math.max(resX, resY);
    const g = ctx.createRadialGradient(resX*0.5, resY*0.5, minR*0.1, resX*0.5, resY*0.5, maxR*0.7);
    g.addColorStop(0, '#0c0f14');
    g.addColorStop(1, '#0a0d12');
    ctx.fillStyle = g; ctx.fillRect(0,0,resX,resY);

    const lw = +ui.lw.value; ui.lwVal.textContent = lw.toFixed(2);
    ctx.lineWidth = lw;
    ctx.globalAlpha = +ui.alpha.value; ui.alphaVal.textContent = (+ui.alpha.value).toFixed(2);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    if(ui.glow.checked){
      ctx.shadowColor = 'rgba(160,190,255,0.35)';
      ctx.shadowBlur = 6;
    } else {
      ctx.shadowBlur = 0; ctx.shadowColor = 'transparent';
    }

    const mul = +ui.mul.value; ui.mulVal.textContent = mul.toFixed(3);
    const offset = +ui.offset.value; ui.offVal.textContent = offset;
    const fan = +ui.fan.value; ui.fanVal.textContent = fan;
    const fstep = +ui.fanStep.value; ui.stepVal.textContent = fstep;

    const skipSame = ui.skipSame.checked;
    const solo = ui.solo.checked;
    const sel = state.selectedIndex = clamp(+ui.selected.value, 0, Math.max(0,total-1));
    ui.selVal.textContent = sel;

    // Draw lines
    ctx.beginPath(); // we'll stroke per color to reduce state changes when solid; for gradients we stroke per line

    const drawLine = (a,b,color) => {
      ctx.strokeStyle = color;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    };

    const connectFrom = (i) => {
      for(let j=0;j<fan;j++){
        const dest = Math.floor((i * mul + offset + j * fstep) % total);
        if(skipSame && sideIndex(i) === sideIndex(dest)) continue;
        drawLine(pins[i], pins[dest], colorFor(i,j,dest));
      }
    };

    if(solo){
      connectFrom(sel);
      // highlight selected pin
      if(ui.showPins.checked || pinR>0){
        ctx.fillStyle = '#ffe082';
        ctx.beginPath(); ctx.arc(pins[sel].x, pins[sel].y, Math.max(pinR, 2.5), 0, Math.PI*2); ctx.fill();
      }
    } else {
      for(let i=0;i<total;i++) connectFrom(i);
    }

    // draw pins if requested
    if(ui.showPins.checked && pinR>0){
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;
      ctx.fillStyle = '#cbd5e1';
      for(const p of pins){
        ctx.beginPath(); ctx.arc(p.x,p.y,pinR,0,Math.PI*2); ctx.fill();
      }
    }
  }

  function rebuildAndDraw(){
    sizeCanvas();
    computePins();
    draw();
  }

  // Interaction: select pin by click
  C.addEventListener('pointerdown', (e)=>{
    const rect = C.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (C.width / rect.width);
    const y = (e.clientY - rect.top) * (C.height / rect.height);
    // find nearest pin
    let bestI = 0, bestD = Infinity;
    for(let i=0;i<state.pins.length;i++){
      const dx = state.pins[i].x - x, dy = state.pins[i].y - y;
      const d2 = dx*dx + dy*dy;
      if(d2 < bestD){bestD = d2; bestI = i;}
    }
    ui.selected.value = bestI; ui.selVal.textContent = bestI;
    draw();
  });

  // Wiring UI
  const bindVal = (input, out, fmt=(v)=>v) => {
    const update = ()=>{out.textContent = fmt(input.value); rebuildAndDraw()};
    input.addEventListener('input', update);
  };

  bindVal(ui.pinsX, ui.nxVal);
  bindVal(ui.pinsY, ui.nyVal);
  bindVal(ui.margin, ui.marginVal);
  bindVal(ui.pinR, ui.pinRVal);
  bindVal(ui.resX, ui.resXVal);
  bindVal(ui.resY, ui.resYVal);

  bindVal(ui.mul, ui.mulVal, v=>(+v).toFixed(3));
  bindVal(ui.offset, ui.offVal);
  bindVal(ui.fan, ui.fanVal);
  bindVal(ui.fanStep, ui.stepVal);
  bindVal(ui.lw, ui.lwVal, v=>(+v).toFixed(2));
  bindVal(ui.selected, ui.selVal);
  bindVal(ui.hue, ui.hueVal);
  bindVal(ui.span, ui.spanVal);
  bindVal(ui.sat, ui.satVal);
  bindVal(ui.lit, ui.litVal);
  bindVal(ui.alpha, ui.alphaVal, v=>(+v).toFixed(2));
  ['showPins','skipSame','solo','glow','colorMode'].forEach(id=> ui[id].addEventListener('change', rebuildAndDraw));
  ui.easyToggle.addEventListener('click', ()=>{ state.easy = !state.easy; applyMode(); rebuildAndDraw(); });

  ui.redraw.addEventListener('click', rebuildAndDraw);

  ui.save.addEventListener('click', ()=>{
    // create a temporary link
    const url = C.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = `string-art_${Date.now()}.png`;
    a.click();
  });

  ui.clearSel.addEventListener('click', ()=>{
    ui.selected.value = 0; ui.selVal.textContent = 0; draw();
  });

  ui.random.addEventListener('click', ()=>{
    const rand = (min,max,step=1)=> Math.round((min + Math.random()*(max-min))/step)*step;
    ui.mul.value = (Math.random()*8 + 1).toFixed(3);
    ui.offset.value = rand(0, 400, 1);
    ui.fan.value = rand(1, 12, 1);
    ui.fanStep.value = rand(1, 80, 1);
    ui.lw.value = (Math.random()*1.5 + 0.2).toFixed(2);
    ui.hue.value = rand(0,360,1);
    ui.span.value = rand(60, 320, 1);
    ui.sat.value = rand(60, 100, 1);
    ui.lit.value = rand(45, 75, 1);
    ui.alpha.value = (Math.random()*0.5 + 0.35).toFixed(2);
    rebuildAndDraw();
  });

  // Resize observer: keep canvas square to container
  const ro = new ResizeObserver(()=>{ sizeCanvas(); draw(); });
  ro.observe(W);

  // First paint
  applyMode();
  rebuildAndDraw();
})();
</script>
</body>
</html>
