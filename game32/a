<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Neon Moiré – Interactive Kinetic Art (with Presets)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.umd.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.min.css" rel="stylesheet"/>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Helvetica,Arial,sans-serif}
    #gui{position:fixed;top:16px;right:16px;z-index:10}
    .tip{position:fixed;left:16px;bottom:16px;color:#aaa;font-size:12px;opacity:.85}
    canvas{display:block}
    .lil-gui .title{letter-spacing:.3px}
  </style>
</head>
<body>
  <div class="tip">Drag: 回転/ズーム（Shift/Altで感度切替）・Spaceで一時停止</div>
  <script>
    // ====== Parameters ======
    const P = {
      pattern: 'curved',       // 'linear' | 'grid' | 'radial' | 'curved'
      layers: 4,
      baseSpacing: 10,
      curvature: 0.35,
      sectors: 4,
      lineThickness: 1.2,
      opacity: 0.14,           // ★ strokeアルファ（以前の固定0.9を修正）
      rotationSpeed: 0.06,
      layerDeltaRot: 7,
      zoom: 1.0,
      zoomPulse: 0.0,
      hueBase: 200,
      hueCycle: 40,
      hueSpeed: 6,
      glow: 18,
      blend: 'add',            // 'add' | 'screen' | 'normal'
      autoDrift: true,
      paused: false
    };

    // ====== Presets ======
    const PRESETS = {
      "Neon Bloom": {
        pattern:'curved', layers:5, baseSpacing:12, lineThickness:1.2, opacity:0.14,
        curvature:0.35, sectors:6, rotationSpeed:0.18, layerDeltaRot:9,
        zoom:1.0, zoomPulse:0.2, hueBase:200, hueCycle:60, hueSpeed:8,
        glow:24, blend:'add', autoDrift:true
      },
      "Psy Spiral": {
        pattern:'curved', layers:6, baseSpacing:10, lineThickness:1.1, opacity:0.12,
        curvature:0.45, sectors:8, rotationSpeed:0.35, layerDeltaRot:13,
        zoom:1.05, zoomPulse:0.35, hueBase:300, hueCycle:90, hueSpeed:12,
        glow:28, blend:'add', autoDrift:true
      },
      "Zen Lines": {
        pattern:'linear', layers:3, baseSpacing:16, lineThickness:1.0, opacity:0.10,
        curvature:0.2, sectors:4, rotationSpeed:0.06, layerDeltaRot:3,
        zoom:1.0, zoomPulse:0.0, hueBase:200, hueCycle:0, hueSpeed:0,
        glow:10, blend:'screen', autoDrift:false
      },
      "Monochrome Classic": {
        pattern:'linear', layers:2, baseSpacing:14, lineThickness:1.4, opacity:0.22,
        curvature:0.2, sectors:4, rotationSpeed:0.08, layerDeltaRot:4,
        zoom:1.0, zoomPulse:0.0, hueBase:0, hueCycle:0, hueSpeed:0,
        glow:0, blend:'normal', autoDrift:false
      },
      "Radial Halo": {
        pattern:'radial', layers:4, baseSpacing:11, lineThickness:1.1, opacity:0.12,
        curvature:0.25, sectors:8, rotationSpeed:0.22, layerDeltaRot:8,
        zoom:1.0, zoomPulse:0.15, hueBase:230, hueCycle:40, hueSpeed:6,
        glow:22, blend:'screen', autoDrift:true
      },
      "Grid Mirage": {
        pattern:'grid', layers:4, baseSpacing:12, lineThickness:1.0, opacity:0.13,
        curvature:0.2, sectors:6, rotationSpeed:0.12, layerDeltaRot:6,
        zoom:1.0, zoomPulse:0.1, hueBase:280, hueCycle:80, hueSpeed:7,
        glow:18, blend:'add', autoDrift:true
      },
      "Vaporwave": {
        pattern:'curved', layers:5, baseSpacing:13, lineThickness:1.2, opacity:0.14,
        curvature:0.32, sectors:4, rotationSpeed:0.10, layerDeltaRot:8,
        zoom:1.1, zoomPulse:0.2, hueBase:300, hueCycle:120, hueSpeed:4,
        glow:20, blend:'screen', autoDrift:true
      },
      "Slow Pulse": {
        pattern:'curved', layers:6, baseSpacing:15, lineThickness:1.3, opacity:0.12,
        curvature:0.28, sectors:6, rotationSpeed:0.03, layerDeltaRot:5,
        zoom:1.0, zoomPulse:0.5, hueBase:190, hueCycle:50, hueSpeed:2,
        glow:16, blend:'add', autoDrift:true
      }
    };

    // ====== State ======
    let t = 0;
    let dragRot = 0, dragZoom = 1.0, px = 0, py = 0, dragging = false;

    function setup(){
      createCanvas(window.innerWidth, window.innerHeight, P2D);
      pixelDensity(2);
      strokeCap(ROUND);
      setupGUI();
      // 起動時プリセット：Neon Bloom
      applyPreset("Neon Bloom");
    }
    function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }

    function draw(){
      background(0);
      if(!P.paused) t += deltaTime/1000;

      if(P.autoDrift && !P.paused){
        P.baseSpacing = clamp(P.baseSpacing + 0.15*Math.sin(t*0.25), 6, 28);
        P.curvature   = clamp(P.curvature   + 0.002*Math.sin(t*0.18+1.7), 0.05, 0.55);
      }

      // 合成
      switch(P.blend){
        case 'add':    blendMode(ADD); break;
        case 'screen': blendMode(SCREEN); break;
        default:       blendMode(BLEND);
      }

      translate(width/2, height/2);
      const R = Math.min(width, height)*0.47*P.zoom*dragZoom;

      // Glow
      const ctx = drawingContext;
      ctx.shadowBlur = P.glow;
      ctx.shadowColor = 'white';

      colorMode(HSL, 360,100,100,1);
      for(let i=0; i<P.layers; i++){
        push();
        const rot = radians(dragRot + i*P.layerDeltaRot + t*P.rotationSpeed*60);
        rotate(rot);
        const hue = (P.hueBase + i*P.hueCycle + t*P.hueSpeed*8) % 360;
        stroke(hue, 100, 60, P.opacity);   // ★ プリセットで透過度を効かせる
        noFill();
        drawPattern(P.pattern, R, P.baseSpacing, P.lineThickness);
        pop();
      }

      if(P.zoomPulse>0 && !P.paused){
        P.zoom += 0.002*P.zoomPulse*Math.sin(t*2.0);
        P.zoom = clamp(P.zoom, 0.6, 1.6);
      }
    }

    function drawPattern(type, R, spacing, thickness){
      strokeWeight(thickness);
      const s = Math.max(4, spacing);

      if(type === 'linear'){
        for(let x=-R; x<=R; x+=s) line(x,-R, x,R);
        circle(0,0, 2*R);
      }
      else if(type === 'grid'){
        for(let x=-R; x<=R; x+=s) line(x,-R, x,R);
        for(let y=-R; y<=R; y+=s) line(-R,y, R,y);
        circle(0,0, 2*R);
      }
      else if(type === 'radial'){
        const count = Math.floor(PI*R/s)*2;
        for(let i=0;i<count;i++){
          const a = (i/count)*TWO_PI;
          const x = R*Math.cos(a), y = R*Math.sin(a);
          line(0,0,x,y);
        }
        circle(0,0, 2*R);
      }
      else { // 'curved'
        const sectors = Math.max(1, Math.floor(P.sectors));
        const stepA = TWO_PI / sectors;
        const linesPerSector = Math.max(12, Math.floor(R/s));
        const k = P.curvature;
        for(let sec=0; sec<sectors; sec++){
          const a0 = sec*stepA, a1 = a0 + stepA;
          for(let i=0;i<linesPerSector;i++){
            const u = i/(linesPerSector-1);
            const a = lerp(a0, a1, u) + k*Math.sin(u*PI*2);
            const x1 = 0.15*R*Math.cos(a - k), y1 = 0.15*R*Math.sin(a - k);
            const x2 = R*Math.cos(a + k),      y2 = R*Math.sin(a + k);
            const cx = 0.55*R*Math.cos(a + PI/2), cy = 0.55*R*Math.sin(a + PI/2);
            beginShape();
            vertex(x1,y1);
            quadraticVertex(cx,cy, x2,y2);
            endShape();
          }
        }
        noFill(); circle(0,0, 2*R);
      }
    }

    // ====== Interaction ======
    function mousePressed(){ dragging = true; px = mouseX; py = mouseY; }
    function mouseReleased(){ dragging = false; }
    function mouseDragged(){
      if(!dragging) return;
      const dx = mouseX - px, dy = mouseY - py;
      if(keyIsDown(SHIFT)) P.zoom = clamp(P.zoom + dy * -0.001, 0.4, 2.2);
      else if(keyIsDown(ALT)) dragZoom = clamp(dragZoom + dy * -0.002, 0.5, 2.5);
      else dragRot += dx * 0.25;
      px = mouseX; py = mouseY;
    }
    function keyPressed(){ if(key === ' ') P.paused = !P.paused; }

    // ====== GUI & Preset Logic ======
    function setupGUI(){
      const gui = new lil.GUI({title:'Controls', container:document.body});
      gui.domElement.id = 'gui';

      // Presets
      const presetFolder = gui.addFolder('Presets');
      const presetState = { name: Object.keys(PRESETS)[0] };
      presetFolder.add(presetState, 'name', Object.keys(PRESETS)).name('Select');
      presetFolder.add({Apply:()=>applyPreset(presetState.name)}, 'Apply').name('Apply');
      presetFolder.add({Random:()=>applyPreset(randomKey(PRESETS))}, 'Random').name('Random');
      presetFolder.add({Export:()=>exportCurrentAsPreset()}, 'Export').name('Export to Console');
      presetFolder.close();

      // Core controls
      gui.add(P,'pattern', ['curved','linear','grid','radial']).name('Pattern');
      gui.add(P,'layers',2,8,1).name('Layers');
      gui.add(P,'baseSpacing',6,40,1).name('Stripe Spacing');
      gui.add(P,'lineThickness',0.5,3,0.1).name('Line Thickness');
      gui.add(P,'opacity',0.05,0.35,0.01).name('Stroke Opacity');
      gui.add(P,'curvature',0.05,0.55,0.01).name('Curvature').listen().disable();
      gui.add(P,'sectors',1,12,1).name('Sectors').listen().disable();
      gui.add(P,'rotationSpeed',0,0.8,0.01).name('Rotation Speed');
      gui.add(P,'layerDeltaRot',-30,30,0.5).name('Layer ΔRot');
      gui.add(P,'zoom',0.5,1.8,0.01).name('Zoom');
      gui.add(P,'zoomPulse',0,1,0.01).name('Zoom Pulse');
      gui.add(P,'hueBase',0,360,1).name('Hue Base');
      gui.add(P,'hueCycle',0,180,1).name('Hue Cycle');
      gui.add(P,'hueSpeed',0,20,0.1).name('Hue Speed');
      gui.add(P,'glow',0,40,1).name('Glow');
      gui.add(P,'blend',['add','screen','normal']).name('Blend');
      gui.add(P,'autoDrift').name('Auto Drift');
      gui.add(P,'paused').name('Pause/Play');

      // enable/disable depending on pattern
      gui.onChange(() => {
        const curvedLike = P.pattern==='curved' || P.pattern==='radial';
        const cCtrl = findControllerByName(gui,'Curvature');
        const sCtrl = findControllerByName(gui,'Sectors');
        if(cCtrl){ curvedLike ? cCtrl.enable() : cCtrl.disable(); }
        if(sCtrl){ curvedLike ? sCtrl.enable() : sCtrl.disable(); }
      });
    }

    function applyPreset(name){
      const p = PRESETS[name];
      if(!p) return;
      Object.assign(P, p);
    }

    function exportCurrentAsPreset(){
      const out = JSON.stringify({
        pattern:P.pattern, layers:P.layers, baseSpacing:P.baseSpacing, lineThickness:P.lineThickness, opacity:P.opacity,
        curvature:P.curvature, sectors:P.sectors, rotationSpeed:P.rotationSpeed, layerDeltaRot:P.layerDeltaRot,
        zoom:P.zoom, zoomPulse:P.zoomPulse, hueBase:P.hueBase, hueCycle:P.hueCycle, hueSpeed:P.hueSpeed,
        glow:P.glow, blend:P.blend, autoDrift:P.autoDrift
      }, null, 2);
      console.log('Copy this into PRESETS:\n', out);
    }

    function findControllerByName(gui, label){
      // lil-guiは直接検索APIがないのでラベル一致で拾う
      const all = document.querySelectorAll('.lil-gui .controller .name');
      for(const el of all){
        if(el.textContent.trim() === label){
          // コントローラ要素から対応するオブジェクトを推測するのは困難なので有効/無効だけ制御
          const ctrl = el.closest('.controller');
          return {
            enable: ()=>ctrl.classList.remove('disabled'),
            disable:()=>ctrl.classList.add('disabled')
          };
        }
      }
      return null;
    }

    function randomKey(obj){
      const ks = Object.keys(obj);
      return ks[Math.floor(Math.random()*ks.length)];
    }

    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  </script>
</body>
</html>